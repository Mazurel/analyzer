package org.analyzer.kotlin.log

import java.time.LocalDate
import java.time.LocalDateTime
import java.time.ZoneOffset
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException

import kotlin.math.min

private val dateFormatters =
        listOf(
                // Yes, they are generated by ChatGPT :)
                DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSZ"),
                DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"),
                DateTimeFormatter.ofPattern("EEE, dd MMM yyyy HH:mm:ss z"),
                DateTimeFormatter.ofPattern("MM/dd/yyyy hh:mm a"),
                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"),
                DateTimeFormatter.ofPattern("dd/MMM/yyyy:HH:mm:ss Z"),
                DateTimeFormatter.ofPattern("yyyyMMdd'T'HHmmssSSS"),
                DateTimeFormatter.ofPattern("EEE MMM dd HH:mm:ss zzz yyyy"),
                DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss"),
                DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss"),
                DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss"),
                DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss"),
                DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm:ss"),
                DateTimeFormatter.ofPattern("HH:mm:ss dd/MM/yyyy"),
                DateTimeFormatter.ofPattern("dd/MMM/yyyy"),
                DateTimeFormatter.ofPattern("yyyy/MM/dd"),
                DateTimeFormatter.ofPattern("MM-dd-yyyy"),
                DateTimeFormatter.ofPattern("dd-MM-yyyy"),
                DateTimeFormatter.ofPattern("dd.MM.yyyy"),
                DateTimeFormatter.ofPattern("MM/dd/yyyy"),
                DateTimeFormatter.ofPattern("yyyy-MM-dd"),
        )

private val timestampSurroundings: List<Pair<Char, Char>> = listOf(
    Pair('[', ']'),
    Pair('(', ')'),
    Pair('{', '}'),
    Pair('<', '>'),
)

class TimestampSubtokens(private val text: String): Iterator<String> {
    private val tokens = text.split(" ").map { it.trim() }.filter { it.length > 0 }
    private var subtokenIndex = min(5, tokens.size - 1)
    private var surroundingsIndex = 0
    private val maxJ = timestampSurroundings.size
    private var nextToken: String?

    init {
        nextToken = null
        while (!isLastState() && nextToken == null) {
            nextToken = tokenByState()
            nextState()
        }
    }

    override operator fun hasNext(): Boolean {
        return nextToken != null && !isLastState()
    }

    override operator fun next(): String {
        val result = nextToken!!

        nextToken = null
        while (nextToken == null && !isLastState()) {
            nextToken = tokenByState()
            nextState()
        }

        return result
    }

    private fun tokenByState(): String? {
        if (surroundingsIndex == 0) {
            return tokens.slice(0..subtokenIndex).joinToString(" ")
        }

        val token = tokens.slice(0..subtokenIndex).joinToString(" ")
        if (token.length <= 2) {
            return null
        }

        val (a, b) = timestampSurroundings[surroundingsIndex - 1]
        if (token.first() == a && token.last() == b) {
            return token.slice(1..token.length - 2)
        }

        return null
    }

    private fun nextState() {
        if (surroundingsIndex >= maxJ) {
            surroundingsIndex = 0
            subtokenIndex -= 1
        }
        else {
            surroundingsIndex += 1
        }
    }

    private fun isLastState(): Boolean {
        return subtokenIndex < 0
    }
}

class Timestamp(private val line: LogLine) {
    // TODO: Using LogFormat
    public val actualEpoch = extractEpoch()
    public var injectedEpoch: Double? = null
    public val epoch get() = if (injectedEpoch != null) injectedEpoch else actualEpoch

    private fun generateSubTokens(): Sequence<String> {
        return TimestampSubtokens(line.line).asSequence()
    }

    private fun extractEpoch(): Double? {
        for (possiblyTimestamp in generateSubTokens()) {
            for (formatter in dateFormatters) {
                try {
                    return LocalDateTime.parse(possiblyTimestamp, formatter)
                            .toInstant(ZoneOffset.UTC)
                            .getEpochSecond()
                            .toDouble()
                } catch (ex: DateTimeParseException) {}
                try {
                    return LocalDate.parse(possiblyTimestamp, formatter).toEpochDay().toDouble()
                } catch (ex: DateTimeParseException) {}
                try {
                    return possiblyTimestamp.toDouble()
                }
                catch (ex: NumberFormatException) {}
            }
        }

        return null
    }
}
